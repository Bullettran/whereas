<!DOCTYPE html>
<html>
<head>
    <title>Платформер с плавной прокруткой</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #222;
        }
        canvas {
            display: block;
            background: url("./public/images/pages/game/level1.gif");
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
    // Инициализация canvas
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 500;

    // Игровые переменные
    const gravity = 0.5;
    let cameraOffset = 0;
    let worldWidth = 3000; // Ширина игрового мира
    let backgroundOffset = 0;

    // Игрок
    const player = {
        x: 100,
        y: 300,
        width: 40,
        height: 60,
        speed: 8, // Увеличена скорость персонажа
        jumpForce: 12,
        velX: 0,
        velY: 0,
        isJumping: false,
        health: 100,
        direction: 1,
        color: '#3498db',

        update: function() {
            // Применение гравитации
            this.velY += gravity;

            // Сохраняем предыдущую позицию X для сравнения
            const prevX = this.x;

            // Обновление позиции
            this.x += this.velX;
            this.y += this.velY;

            // Зоны прокрутки камеры (30% от ширины экрана с каждой стороны)
            const scrollZoneLeft = canvas.width * 0.3;
            const scrollZoneRight = canvas.width * 0.7;

            // Вычисляем позицию игрока относительно экрана
            const playerScreenX = this.x - cameraOffset;

            // Движение камеры вправо
            if (playerScreenX > scrollZoneRight && cameraOffset < worldWidth - canvas.width) {
                cameraOffset += this.x - prevX; // Камера движется ровно настолько, насколько движется игрок
                backgroundOffset += (this.x - prevX) * 0.5;
            }

            // Движение камеры влево
            if (playerScreenX < scrollZoneLeft && cameraOffset > 0) {
                cameraOffset += this.x - prevX; // Аналогично для движения влево
                backgroundOffset += (this.x - prevX) * 0.5;
            }

            // Ограничение выхода за пределы мира
            if (this.x < 0) this.x = 0;
            if (this.x + this.width > worldWidth) this.x = worldWidth - this.width;

            // Ограничение падения за пределы экрана
            if (this.y + this.height > canvas.height) {
                this.y = canvas.height - this.height;
                this.velY = 0;
                this.isJumping = false;
            }

            // Гарантируем, что игрок всегда виден на экране
            if (this.x < cameraOffset) {
                this.x = cameraOffset;
            } else if (this.x > cameraOffset + canvas.width - this.width) {
                this.x = cameraOffset + canvas.width - this.width;
            }
        },

        draw: function() {
            // Рисование игрока (с учетом смещения камеры)
            ctx.save();
            ctx.translate(-cameraOffset, 0);

            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);

            // Рисование здоровья
            ctx.fillStyle = 'red';
            ctx.fillRect(this.x, this.y - 10, this.width, 5);
            ctx.fillStyle = 'green';
            ctx.fillRect(this.x, this.y - 10, this.width * (this.health / 100), 5);

            ctx.restore();
        },

        jump: function() {
            if (!this.isJumping) {
                this.velY = -this.jumpForce;
                this.isJumping = true;
            }
        }
    };

    // Платформы
    const platforms = [
        {x: 100, y: 400, width: 200, height: 20},
        {x: 400, y: 350, width: 200, height: 20},
        {x: 700, y: 300, width: 150, height: 20},
        {x: 1000, y: 400, width: 200, height: 20},
        {x: 1300, y: 350, width: 200, height: 20},
        {x: 1600, y: 300, width: 150, height: 20},
        {x: 2000, y: 400, width: 300, height: 20},
        {x: 2500, y: 300, width: 200, height: 20}
    ];

    // Фоновые элементы (для параллакс эффекта)
    const backgroundElements = [
        {x: 0, y: 100, width: 500, height: 100, color: '#2c3e50'},
        {x: 600, y: 150, width: 400, height: 120, color: '#2c3e50'},
        {x: 1200, y: 80, width: 600, height: 150, color: '#2c3e50'},
        {x: 2000, y: 120, width: 500, height: 100, color: '#2c3e50'},
        {x: 2600, y: 150, width: 400, height: 120, color: '#2c3e50'}
    ];

    // Управление
    const keys = {
        left: false,
        right: false,
        up: false
    };

    document.addEventListener('keydown', (e) => {
        switch(e.key) {
            case 'ArrowLeft':
                keys.left = true;
                player.direction = -1;
                break;
            case 'ArrowRight':
                keys.right = true;
                player.direction = 1;
                break;
            case 'ArrowUp':
                keys.up = true;
                break;
        }
    });

    document.addEventListener('keyup', (e) => {
        switch(e.key) {
            case 'ArrowLeft':
                keys.left = false;
                break;
            case 'ArrowRight':
                keys.right = false;
                break;
            case 'ArrowUp':
                keys.up = false;
                break;
        }
    });

    // Игровой цикл
    function gameLoop() {
        // Очистка экрана
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Рисование фона с параллакс эффектом
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Рисование фоновых элементов
        ctx.fillStyle = '#34495e';
        backgroundElements.forEach(element => {
            const xPos = element.x - backgroundOffset * 0.3;
            if (xPos + element.width > 0 && xPos < canvas.width) {
                ctx.fillRect(xPos, element.y, element.width, element.height);
            }
        });

        // Обновление игрока
        player.velX = 0;
        if (keys.left) player.velX = -player.speed;
        if (keys.right) player.velX = player.speed;
        if (keys.up) player.jump();

        player.update();

        // Проверка столкновений с платформами
        platforms.forEach(platform => {
            const platformScreenX = platform.x - cameraOffset;

            // Рисование платформы (только если она видима на экране)
            if (platformScreenX + platform.width > 0 && platformScreenX < canvas.width) {
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(platformScreenX, platform.y, platform.width, platform.height);

                // Проверка столкновений
                if (
                    player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height &&
                    player.velY > 0
                ) {
                    player.y = platform.y - player.height;
                    player.velY = 0;
                    player.isJumping = false;
                }
            }
        });

        // Отрисовка игрока
        player.draw();

        // Отрисовка информации о позиции
        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText(`Позиция: ${Math.floor(player.x + cameraOffset)}/${worldWidth}`, 20, 30);
        ctx.fillText(`Скорость: ${player.speed}`, 20, 50);

        // Продолжение игрового цикла
        requestAnimationFrame(gameLoop);
    }

    // Запуск игры
    gameLoop();
</script>
</body>
</html>